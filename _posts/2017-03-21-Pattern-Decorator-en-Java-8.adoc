= Pattern Decorator en Java 8
:published_at: 2017-03-21
:source-highlighter: highlightjs

== 1) Introduction

L'objectif de cette article est de parler d'un des pattern du GOF (gang of four) assez connu, qui est le decorator.
Ce patron de conception correspond à un design pattern de type comportement (behavioural pattern).

En gros l'idée de ce pattern est d'ajouter du comportement à du code au runtime (c'est à dire à l'execution du code).
Ce pattern présente de nombreux avantages car lorsque la conception a été mise en place, il devient très simple d'ajouter du comportement au code existant, ce qui le rend très evolutif.

Avant Java 8, malgré l'aspect interessant évoqué précédement, ce pattern n'était pas beaucoup utilisé car le code nécessaire à sa mise en place était très verbeux.
En effet le design de code était basé sur l'héritage, ce qui obligeait le développeur à écrire une interface par décorator, assez qu'une classe abstraite. La verbosité induite par ce type de dévéloppement pouvait décourager pas mal de développeurs.

En Java 8 avec l'apport des lambdas, nous allons montrer que le decorator est beaucoup plus simple à implémenter, moins verbeux, fonctionnel et plus lisible pour le client de l'API.

L'article se décompose en 2 partie consistant à montrer le code et la conception du decorator avant et après Java 8. En Java 8 nous montrerons différentes techniques.

L'exemple choisi pour illustrer ce pattern, est le calcul du bénéfice d'une entreprise. Chaque nouveau decorator permettra d'ajouter un calcul au runtime à la formule générale.

== 2) Decorator en Java 7

Premièrement une interface définissant le contrat doit être créée, nous allons l'appeler ProfitCalculator (calculateur de bénéfice). Voici le code de cette interface : 

[source,java]
----
public interface ProfitCalculator {

  double calculate(double turnover);
}  
----

Un calculateur de profit dispose d'une méthode abstraite "calculate", qui va appliquer un nouveau calcul au CA passé en paramètre.

Ensuite il faut créer une classe abstraite que l'on va appeler AbstractProfitDecorator : 

[source,java]
----
public abstract class AbstractProfitDecorator implements ProfitCalculator {

  private final ProfitCalculator profitCalculator;

  public AbstractProfitDecorator(ProfitCalculator profitCalculator) {
    this.profitCalculator = profitCalculator;
  }

  protected abstract double applyExpense(double turnover);

  @Override
  public double calculate(double turnover) {
    double profit = profitCalculator.calculate(turnover);
    return applyExpense(profit);
  }
}
----

Cette classe implémente l'interface précédente et doit donc proposer l'implémentation de la méthode "calculate(double turnover)". 
Chaque décorator va appliquer une dépense en proposant l'implémentation de la méthode "applyExpense(double turnover)".

Une subtilité est à constater içi, la classe prend également en paramètre l'interface "ProfitCalculator". 
En effet, chaque decorator va appliquer le calcul du decorator qui le précède et va ensuite y ajouter son calcul à lui. C'est ce comportement qui permet d'ajouter des traitements au runtime.

Nous allons commencer par une classe proposant un calcul par défaut, appelé "DefaultProfitCalculator". Il est en effet utile de commencer par une classe de type "profitCalculator" qui ne dépend de rien lors de son instantiation. Ceci correspond au calcul initial des decorators : 

[source,java]
----
public class DefaultProfitCalculator implements ProfitCalculator {

  @Override
  public double calculate(double turnover) {
    return Expenses.getTransportExpenses(turnover);
  }
}
----

Nous allons ensuite montrer le code des différents decorators : 

Charges d'exploitation => OperatingExpensesDecorator : 
[source,java]
----
public class OperatingExpensesDecorator extends AbstractProfitDecorator {

  public OperatingExpensesDecorator(ProfitCalculator profitCalculator) {
    super(profitCalculator);
  }

  @Override
  protected double applyExpense(double turnover) {
    return Expenses.getOperatingExpenses(turnover);
  }
}
----

Rémunération => RemunerationDecorator : 
[source,java]
----
public class RemunerationDecorator extends AbstractProfitDecorator {

  public RemunerationDecorator(ProfitCalculator profitCalculator) {
    super(profitCalculator);
  }

  @Override
  protected double applyExpense(double turnover) {
    return Expenses.getRemuneration(turnover);
  }
}
----

Dépenses exceptionnelles => ExceptionalExpensesDecorator : 
[source,java]
----
public class ExceptionalExpensesDecorator extends AbstractProfitDecorator {

  public ExceptionalExpensesDecorator(ProfitCalculator profitCalculator) {
    super(profitCalculator);
  }

  @Override
  protected double applyExpense(double turnover) {
    return Expenses.getExceptionalExpenses(turnover);
  }
}
----

Taxes déductible => DeductibleTaxesDecorator : 
[source,java]
----
public class DeductibleTaxesDecorator extends AbstractProfitDecorator {

  public DeductibleTaxesDecorator(ProfitCalculator profitCalculator) {
    super(profitCalculator);
  }

  @Override
  protected double applyExpense(double turnover) {
    return Expenses.getDeductibleTaxes(turnover);
  }
}
----

Le principe de chaque dcorator est le même, chacun doit proposer une implémentation de la méthide "applyExpense". Il est noter que les cas choisis ne reflètent pas forcemment la réalité, mais servent juste d'exemple.
Une "garbage class" appelée Expenses contient des méthodes statiques permettant de calculer chaque cas. Nous monterons cette classe un peu plus tard.

Nous allons désormais passer aux tests d'intégration et à l'appel des décorators. 

Le premier test permet de composer tous les décorators : 

[source,java]
----
@Test
  public void givenTurnover_whenComposingAllDecorators_thenCorrectResult() {

    // Given.
    final double turnover = 100000;

    // When.
    final double profit =
        new ExceptionalExpensesDecorator(new RemunerationDecorator(new DeductibleTaxesDecorator(new OperatingExpensesDecorator(new DefaultProfitCalculator())))).calculate(turnover);

    // Then.
    assertThat(profit).isNotNull().isEqualTo(32600);
  }
----

Le calcul commence de droite à gauche, on commence par le DefaultProfitCalculator, enuite cette classe est passée en paramètre du décorator OperatingExpensesDecorator et ainsi de suite.
OperatingExpensesDecorator applique le calcul de DefaultProfitCalculator plus le sien.

Voici un second test qui n'applique pas tous les décorator, et montre qu'il est très simple d'ajouter ou de supprimer un decorator au runtime. Le code peut ainsi être évolutif.
